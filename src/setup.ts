/**
 * Interactive first-run setup: `bryti hail`
 *
 * Walks the user through creating a working config.yml with the minimum
 * needed to start: a model provider and a Telegram bot. Everything else
 * has sensible defaults.
 */

import fs from "node:fs";
import path from "node:path";
import readline from "node:readline";
import { resolveDataDir } from "./config.js";

// ---------------------------------------------------------------------------
// Prompt helpers
// ---------------------------------------------------------------------------

function createPrompt(): {
  ask: (question: string, fallback?: string) => Promise<string>;
  askSecret: (question: string) => Promise<string>;
  choose: (question: string, options: string[], fallback?: number) => Promise<number>;
  close: () => void;
} {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });

  const ask = (question: string, fallback?: string): Promise<string> =>
    new Promise((resolve) => {
      const suffix = fallback ? ` [${fallback}]` : "";
      rl.question(`  ${question}${suffix}: `, (answer) => {
        resolve(answer.trim() || fallback || "");
      });
    });

  const askSecret = (question: string): Promise<string> =>
    new Promise((resolve) => {
      // Mute output while typing
      const stdout = process.stdout;
      rl.question(`  ${question}: `, (answer) => {
        resolve(answer.trim());
      });
      // Hide input by overwriting with nothing
      const origWrite = stdout.write.bind(stdout);
      (stdout as any).write = (chunk: string, ...args: any[]) => {
        if (typeof chunk === "string" && chunk.includes(question)) {
          return origWrite(chunk, ...args);
        }
        // Don't echo typed characters
        return true;
      };
      rl.once("close", () => { (stdout as any).write = origWrite; });
      // Restore after answer
      const restore = () => {
        (stdout as any).write = origWrite;
        origWrite("\n");
      };
      rl.once("line", restore);
    });

  const choose = (question: string, options: string[], fallback = 0): Promise<number> =>
    new Promise((resolve) => {
      console.log(`  ${question}`);
      for (let i = 0; i < options.length; i++) {
        const marker = i === fallback ? ">" : " ";
        console.log(`  ${marker} ${i + 1}. ${options[i]}`);
      }
      rl.question(`  Choice [${fallback + 1}]: `, (answer) => {
        const n = parseInt(answer.trim(), 10);
        if (n >= 1 && n <= options.length) {
          resolve(n - 1);
        } else {
          resolve(fallback);
        }
      });
    });

  return { ask, askSecret, choose, close: () => rl.close() };
}

// ---------------------------------------------------------------------------
// Config generation
// ---------------------------------------------------------------------------

function generateConfig(opts: {
  name: string;
  provider: string;
  apiKey: string;
  model: string;
  telegramToken: string;
  telegramUserId: string;
  timezone: string;
}): string {
  const lines: string[] = [
    "# Bryti configuration",
    "# Generated by 'bryti hail'. Edit freely.",
    "",
    "agent:",
    `  name: ${opts.name}`,
    `  model: ${opts.provider}/${opts.model}`,
    `  timezone: ${opts.timezone}`,
    "",
    "telegram:",
    `  token: \${TELEGRAM_BOT_TOKEN}`,
    `  allowed_users:`,
    `    - ${opts.telegramUserId}`,
    "",
    "models:",
    "  providers:",
  ];

  if (opts.provider === "anthropic") {
    const apiLine = opts.apiKey
      ? "      api_key: ${ANTHROPIC_API_KEY}"
      : '      api_key: ""';
    lines.push(
      "    - name: anthropic",
      "      api: anthropic-messages",
      apiLine,
      "      models:",
      `        - id: ${opts.model}`,
    );
  } else if (opts.provider === "openai") {
    const apiLine = opts.apiKey
      ? "      api_key: ${OPENAI_API_KEY}"
      : '      api_key: ""';
    lines.push(
      "    - name: openai",
      "      api: openai-completions",
      apiLine,
      "      models:",
      `        - id: ${opts.model}`,
    );
  } else if (opts.provider === "opencode") {
    lines.push(
      "    - name: opencode",
      "      api: openai-completions",
      "      base_url: https://opencode-ai.com/v1/openai",
      "      api_key: none",
      "      models:",
      `        - id: ${opts.model}`,
    );
  }

  lines.push("");
  return lines.join("\n") + "\n";
}

function generateEnv(opts: {
  provider: string;
  apiKey: string;
  telegramToken: string;
}): string {
  const lines: string[] = [];

  lines.push(`TELEGRAM_BOT_TOKEN=${opts.telegramToken}`);

  if (opts.provider === "anthropic" && opts.apiKey) {
    lines.push(`ANTHROPIC_API_KEY=${opts.apiKey}`);
  } else if (opts.provider === "openai" && opts.apiKey) {
    lines.push(`OPENAI_API_KEY=${opts.apiKey}`);
  }

  lines.push("");
  return lines.join("\n");
}

// ---------------------------------------------------------------------------
// Main
// ---------------------------------------------------------------------------

export async function runSetup(targetDir?: string): Promise<void> {
  const dataDir = targetDir ? path.resolve(targetDir) : resolveDataDir();

  console.log("");
  console.log("  ᛒ  Bryti hails you.");
  console.log("");
  console.log("  Let's set up your AI colleague.");
  console.log(`  Config will be written to: ${dataDir}`);
  console.log("");

  if (fs.existsSync(path.join(dataDir, "config.yml"))) {
    console.log("  A config.yml already exists here. Run 'bryti serve' to start.");
    console.log("");
    return;
  }

  const prompt = createPrompt();

  try {
    // --- Name ---
    const name = await prompt.ask("What should your bryti be called?", "Bryti");

    // --- Provider ---
    console.log("");
    const providerIdx = await prompt.choose("Which model provider?", [
      "Anthropic (Claude)",
      "OpenAI (GPT)",
      "OpenCode (free, no API key)",
    ], 0);
    const providerMap = ["anthropic", "openai", "opencode"] as const;
    const provider = providerMap[providerIdx];

    // --- Auth method ---
    let apiKey = "";
    let useOAuth = false;
    if (provider === "anthropic" || provider === "openai") {
      console.log("");
      const providerName = provider === "anthropic" ? "Anthropic" : "OpenAI";
      const authIdx = await prompt.choose(`How do you authenticate with ${providerName}?`, [
        `${providerName} subscription (Max/Pro/Plus plan)`,
        "API key",
      ], 0);

      if (authIdx === 1) {
        const keyUrl = provider === "anthropic"
          ? "https://console.anthropic.com/settings/keys"
          : "https://platform.openai.com/api-keys";
        console.log(`  Get an API key at: ${keyUrl}`);
        apiKey = await prompt.ask(`${providerName} API key`);
      } else {
        useOAuth = true;
        console.log(`  Bryti will use your ${providerName} subscription via OAuth.`);
        console.log("  You'll be prompted to sign in on first start.");
      }
    }

    // --- Model ---
    let model: string;
    if (provider === "anthropic") {
      model = "claude-sonnet-4-6";
    } else if (provider === "openai") {
      model = "gpt-4.1";
    } else {
      model = "MiniMax-M2-5";
    }
    console.log(`  Using model: ${model}`);

    // --- Telegram ---
    console.log("");
    console.log("  Now let's connect to Telegram.");
    console.log("  1. Open Telegram and message @BotFather");
    console.log("  2. Send /newbot and follow the steps");
    console.log("  3. Copy the bot token it gives you");
    console.log("");
    const telegramToken = await prompt.ask("Telegram bot token");

    console.log("");
    console.log("  To find your Telegram user ID:");
    console.log("  Message @userinfobot on Telegram. It replies with your ID.");
    console.log("");
    const telegramUserId = await prompt.ask("Your Telegram user ID");

    // --- Timezone ---
    const defaultTz = Intl.DateTimeFormat().resolvedOptions().timeZone;
    const timezone = await prompt.ask("Timezone", defaultTz);

    // --- Write files ---
    console.log("");
    fs.mkdirSync(dataDir, { recursive: true });

    const configContent = generateConfig({
      name,
      provider,
      apiKey,
      model,
      telegramToken,
      telegramUserId,
      timezone,
    });
    fs.writeFileSync(path.join(dataDir, "config.yml"), configContent, "utf-8");

    const envContent = generateEnv({ provider, apiKey, telegramToken });
    fs.writeFileSync(path.join(dataDir, ".env"), envContent, "utf-8");

    // Copy default extensions
    const pkgRoot = path.resolve(new URL(".", import.meta.url).pathname, "..");
    const defaultExtDir = path.join(pkgRoot, "defaults", "extensions");
    const extDir = path.join(dataDir, "files", "extensions");
    if (fs.existsSync(defaultExtDir)) {
      fs.mkdirSync(extDir, { recursive: true });
      for (const file of fs.readdirSync(defaultExtDir)) {
        fs.copyFileSync(path.join(defaultExtDir, file), path.join(extDir, file));
      }
    }

    console.log("  ✓ Config written to " + path.join(dataDir, "config.yml"));
    console.log("  ✓ Secrets written to " + path.join(dataDir, ".env"));
    console.log("");
    console.log("  Your steward is ready. Start with:");
    console.log("");
    if (dataDir === resolveDataDir()) {
      console.log("    bryti");
    } else {
      console.log(`    BRYTI_DATA_DIR=${dataDir} bryti`);
    }
    console.log("");
  } finally {
    prompt.close();
  }
}
